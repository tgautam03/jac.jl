var documenterSearchIndex = {"docs":
[{"location":"#JAC","page":"Home","title":"JAC","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"JAC(obian) is a simple Reverse Mode Automatic Differentiation (AD) Library written from scratch in Julia. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is strictly for educational purposes only, as I won't be focusing on performance (per say). ","category":"page"},{"location":"#Reverse-mode-Automatic-Differentiation-Theory","page":"Home","title":"Reverse-mode Automatic Differentiation Theory","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Theory behind AD is simple. It's all about chain rule! ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Consider a simple function f(xy)=(xy+y^3)^2, and the task is to evaluate the exact derivatives of f with respect to x and y, i.e. fracpartial fpartial x and fracpartial fpartial y. I'm sure you can compute these by hand but it would be nice to have a computer program evaluate exact derivatives automatically. This will come in handy if the function changes to say f(xy)=(xy+y^3x^4)^3, and you don't have to rewrite a single line of code! ","category":"page"},{"location":"","page":"Home","title":"Home","text":"What an AD Engine does is break down the complex function into simpler sections involving a single operation. For example, f(xy)=(xy+y^3)^2 can be rewritten as","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_1 = x cdot y tag1","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_2 = y^3 tag2","category":"page"},{"location":"","page":"Home","title":"Home","text":"f_3 = f_1 + f_2 tag3","category":"page"},{"location":"","page":"Home","title":"Home","text":"f(xy) = f_3^2 tag4","category":"page"},{"location":"","page":"Home","title":"Home","text":"A nice way to visualise these operations is on a computation graph as shown below","category":"page"},{"location":"","page":"Home","title":"Home","text":"flowchart LR\nx[x] -->mul{.}\ny[y] -->mul{.}\nmul -->|Multiply| f1(f1)\ny -->pow{^3}\npow -->|Power| f2(f2)\nf1 -->add{+}\nf2 -->add{+}\nadd -->|Add| f3(f3)\nf3 --> pow2{^2}\npow2 -->|Power| f[f]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Now, we can evaluate derivatives easily for each of these equations separately","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial f_1partial x=y    fracpartial f_1partial y=x tag5","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial f_2partial y=3y^2 tag6","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial f_3partial f_1=1    fracpartial f_3partial f_2=1 tag7","category":"page"},{"location":"","page":"Home","title":"Home","text":"fracpartial f(xy)partial f_3=2f_3 tag8","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let's just call these Local Derivatives as they're defined locally on the each step. We can represent these on the graph as well","category":"page"},{"location":"","page":"Home","title":"Home","text":"flowchart LR\nx[x] --> |y| mul{.}\ny[y] --> |x| mul{.}\nmul --> f1(f1)\ny --> |3y^2| pow{^3}\npow --> f2(f2)\nf1 --> |1| add{+}\nf2 --> |1| add{+}\nadd --> f3(f3)\nf3 --> |2f3| pow2{^2}\npow2 --> f[f]","category":"page"},{"location":"","page":"Home","title":"Home","text":"Getting the desired Global Derivatives is just a matter of moving through the graph in reverse (hence the name Reverse-mode Automatic Differentiation). Let me demonstrate that step by step","category":"page"}]
}
